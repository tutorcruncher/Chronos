import hashlib
import hmac
import json
from datetime import datetime, timedelta

import requests
from celery.app import Celery
from fastapi import APIRouter
from fastapi_utilities import repeat_at
from sqlalchemy import delete
from sqlmodel import Session, col, select

from chronos.db import engine
from chronos.pydantic_schema import RequestData
from chronos.sql_models import WebhookEndpoint, WebhookLog
from chronos.utils import app_logger, settings

session = requests.Session()
cronjob = APIRouter()

celery_app = Celery(__name__, broker=settings.redis_url, backend=settings.redis_url)
celery_app.conf.broker_connection_retry_on_startup = True


def webhook_request(url: str, *, method: str = 'POST', webhook_sig: str, data: dict = None):
    """
    Send a request to TutorCruncher
    :param url: The endpoint supplied by clients when creating an integration in TC2
    :param method: We should always be sending POST requests as we are sending data to the endpoints
    :param webhook_sig: The signature generated by hashing the payload with the shared key
    :param data: The Webhook data supplied by TC2
    :return: WebhookEndpoint response
    """
    from chronos.main import logfire

    headers = {
        'User-Agent': 'TutorCruncher',
        'Content-Type': 'application/json',
        'webhook-signature': webhook_sig,
    }
    logfire.debug('TutorCruncher request to url: {url=}: {data=}', url=url, data=data)
    with logfire.span('{method=} {url!r}', url=url, method=method):
        r = None
        try:
            r = session.request(method=method, url=url, json=data, headers=headers)
        except requests.exceptions.HTTPError as httperr:
            app_logger.info('HTTP error sending webhook to %s: %s', url, httperr)
        except requests.exceptions.ConnectionError as conerr:
            app_logger.info('Connection error sending webhook to %s: %s', url, conerr)
        except requests.exceptions.Timeout as terr:
            app_logger.info('Timeout error sending webhook to %s: %s', url, terr)
        except requests.exceptions.RequestException as rerr:
            app_logger.info('Request error sending webhook to %s: %s', url, rerr)
        else:
            app_logger.info('Request method=%s url=%s status_code=%s', method, url, r.status_code, extra={'data': data})

    request_data = RequestData(request_headers=json.dumps(headers), request_body=json.dumps(data))
    if r is None:
        webhook_was_received = False
    else:
        request_data.response_headers = json.dumps(dict(r.headers))
        request_data.response_body = json.dumps(r.content.decode())
        request_data.status_code = r.status_code
        webhook_was_received = True

    return request_data, webhook_was_received


acceptable_url_schemes = ('http', 'https', 'ftp', 'ftps')


@celery_app.task
def task_send_webhooks(
    payload: str,
    url_extension: str = None,
):
    """
    Send the webhook to the relevant endpoints
    """
    loaded_payload = json.loads(payload)
    loaded_payload['_request_time'] = loaded_payload.pop('request_time')
    branch_id = loaded_payload['events'][0]['branch']

    total_success, total_failed = 0, 0
    with Session(engine) as db:
        # Get all the endpoints for the branch
        endpoints_query = select(WebhookEndpoint).where(WebhookEndpoint.branch_id == branch_id, WebhookEndpoint.active)
        endpoints = db.exec(endpoints_query).all()
        for endpoint in endpoints:
            # Check if the webhook URL is valid
            if not endpoint.webhook_url.startswith(acceptable_url_schemes):
                app_logger.error(
                    'Webhook URL does not start with an acceptable url scheme: %s (%s)',
                    endpoint.webhook_url,
                    endpoint.id,
                )
                continue
            # Create sig for the endpoint
            webhook_sig = hmac.new(endpoint.api_key.encode(), json.dumps(payload).encode(), hashlib.sha256)
            sig_hex = webhook_sig.hexdigest()

            url = endpoint.webhook_url
            if url_extension:
                url += f'/{url_extension}'
            # Send the Webhook to the endpoint
            response, webhook_sent = webhook_request(url, webhook_sig=sig_hex, data=loaded_payload)

            if not webhook_sent:
                app_logger.error('No response from endpoint %s: %s', endpoint.id, endpoint.webhook_url)

            if response.status_code in {200, 201, 202, 204}:
                status = 'Success'
                total_success += 1
            else:
                status = 'Unexpected response'
                total_failed += 1

            # Log the response
            webhooklog = WebhookLog(
                webhook_endpoint_id=endpoint.id,
                request_headers=response.request_headers,
                request_body=response.request_body,
                response_headers=response.response_headers,
                response_body=response.response_body,
                status=status,
                status_code=response.status_code,
            )
            db.add(webhooklog)
        db.commit()
    app_logger.info(
        '%s Webhooks sent for branch %s. Total Sent: %s. Total failed: %s',
        total_success + total_failed,
        branch_id,
        total_success,
        total_failed,
    )


@cronjob.on_event('startup')
@repeat_at(cron='0 0 * * *')
async def delete_old_logs_job():
    """
    We run cron job at midnight every day that wipes all WebhookLogs older than 15 days
    """
    _delete_old_logs_job.delay()


@celery_app.task
def _delete_old_logs_job():
    with Session(engine) as db:
        # Get all logs older than 15 days
        statement = select(WebhookLog).where(WebhookLog.timestamp > datetime.utcnow() - timedelta(days=15))
        results = db.exec(statement).all()

        # Delete the logs
        delete_statement = delete(WebhookLog).where(col(WebhookLog.id).in_([whl.id for whl in results]))
        db.exec(delete_statement)
        db.commit()

        app_logger.info(f'Deleting {len(results)} logs')
